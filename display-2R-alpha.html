<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blue 7○3× System</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@700&display=swap');
:root {
  --bg-color: #020617;
  --panel-bg: #0f172a;
  --border-color: #1e293b;
  --accent-blue: #3b82f6;
  --accent-cyan: #06b6d4;
  --accent-red: #ef4444;
  --accent-gold: #f59e0b;
  --text-main: #f8fafc;
  --text-muted: #94a3b8;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Noto Sans JP', sans-serif;
  background: var(--bg-color);
  color: var(--text-main);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header Area */
.header {
  height: 60px;
  background: linear-gradient(90deg, #0f172a, #1e293b);
  border-bottom: 2px solid var(--accent-cyan);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  flex-shrink: 0;
}

.title-area {
  font-size: 24px;
  font-weight: 900;
  color: var(--accent-cyan);
  text-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
  display: flex;
  align-items: center;
  gap: 15px;
}

.stats-area {
  font-size: 28px;
  font-weight: 900;
  color: #fff;
  background: rgba(0,0,0,0.3);
  padding: 5px 20px;
  border-radius: 4px;
  border: 1px solid var(--border-color);
}
.stats-label { font-size: 12px; color: var(--text-muted); margin-right: 10px; vertical-align: middle; }

/* Question Display Area */
.question-panel {
  background: #000;
  border-bottom: 1px solid #333;
  padding: 10px 20px;
  min-height: 80px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  position: relative;
}
.q-text { font-size: 20px; color: #fff; margin-bottom: 5px; line-height: 1.4; }
.a-text { font-size: 18px; color: var(--accent-gold); font-weight: bold; opacity: 0; transition: opacity 0.3s; }
.a-text.visible { opacity: 1; }
.q-controls {
  position: absolute; top: 10px; right: 20px;
  display: flex; gap: 10px;
}

/* Main Grid */
.main-content {
  flex: 1;
  display: flex;
  padding: 10px;
  gap: 6px;
  background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
  overflow: hidden;
}

.player-col {
  flex: 1;
  display: flex;
  flex-direction: column;
  border: 1px solid #334155;
  background: rgba(15, 23, 42, 0.8);
  height: 100%;
  border-radius: 4px;
  position: relative;
  transition: all 0.3s;
}

/* Player Column Layout */
.p-header {
  height: 50px;
  background: rgba(255,255,255,0.05);
  border-bottom: 1px solid #334155;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.p-rank-badge { font-size: 12px; color: var(--text-muted); }

.p-body {
  flex: 1;
  writing-mode: vertical-rl;
  text-orientation: upright;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  letter-spacing: 4px;
  color: #fff;
  background: linear-gradient(180deg, rgba(6, 182, 212, 0.1) 0%, rgba(6, 182, 212, 0.0) 100%);
  transition: background 0.3s;
  cursor: pointer;
  user-select: none;
}
.name-input {
  background: transparent; border: none; color: inherit;
  font: inherit; text-align: center; width: 100%; height: 100%;
  writing-mode: vertical-rl; text-orientation: upright;
  outline: none;
}

.p-score-box {
  height: 100px;
  border-top: 1px solid #334155;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.2);
}
.score-val { font-size: 48px; color: var(--accent-cyan); font-weight: 800; line-height: 1; }
.score-x { font-size: 16px; color: var(--accent-red); margin-top: 5px; height: 20px; font-weight: bold; }
.winner-badge { background: var(--accent-red); color: white; padding: 5px 10px; border-radius: 4px; font-size: 14px; }

.p-controls {
  display: flex;
  height: 40px;
  border-top: 1px solid #334155;
}
.btn-point { flex: 1; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; color: #fff; }
.btn-plus { background: #0f766e; } /* Teal-ish */
.btn-plus:hover { background: #115e59; }
.btn-minus { background: #991b1b; } /* Red-ish */
.btn-minus:hover { background: #7f1d1d; }

/* States */
.player-col.winner { border: 2px solid var(--accent-gold); box-shadow: 0 0 15px rgba(245, 158, 11, 0.3); }
.player-col.winner .p-body { background: linear-gradient(180deg, rgba(245, 158, 11, 0.2) 0%, rgba(0,0,0,0) 100%); }
.player-col.winner .score-val { color: var(--accent-gold); }

.player-col.eliminated { opacity: 0.6; border-color: #333; background: #050505; }
.player-col.eliminated .p-body { color: #555; background: none; }
.player-col.eliminated .score-val { color: #555; }

/* Footer Controls */
.control-bar {
  background: #0f172a;
  padding: 10px 20px;
  display: flex;
  gap: 15px;
  border-top: 1px solid #333;
  align-items: center;
  flex-wrap: wrap;
}
.input-group { display: flex; align-items: center; gap: 5px; font-size: 14px; color: #ccc; }
.input-group input { background: #1e293b; border: 1px solid #475569; color: #fff; padding: 4px; width: 50px; text-align: center; border-radius: 4px; }
.btn-sys { background: #334155; border: none; color: white; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
.btn-sys:hover { background: #475569; }
.btn-reset { background: #7f1d1d; }

input[type="file"] { color: #94a3b8; font-size: 12px; }

/* Anim */
@keyframes pop { 0%{transform: scale(1);} 50%{transform: scale(1.3);} 100%{transform: scale(1);} }
.pop-anim { animation: pop 0.2s; }
</style>
</head>
<body>

<div class="header">
  <div class="title-area">
    <span>System: Blue-α</span>
  </div>
  <div class="stats-area">
    <span class="stats-label">ALIVE >>> LEFTS</span>
    <span id="headerStats">0 >>> 0</span>
  </div>
</div>

<div class="question-panel">
  <div class="q-text" id="qText">Q. CSVファイルを読み込むとここに問題が表示されます</div>
  <div class="a-text" id="aText">A. 解答はここに表示されます</div>
  <div class="q-controls">
    <button class="btn-sys" id="prevQ">&lt;</button>
    <button class="btn-sys" id="showA">Ans</button>
    <button class="btn-sys" id="nextQ">&gt;</button>
  </div>
</div>

<div class="main-content" id="grid">
  </div>

<div class="control-bar">
  <div class="input-group">
    <label>WIN</label><input type="number" id="winThresh" value="5">
  </div>
  <div class="input-group">
    <label>LOSE</label><input type="number" id="loseThresh" value="2">
  </div>
  <div class="input-group">
    <label>NUM</label><input type="number" id="playerCount" value="6">
  </div>
  <button class="btn-sys" id="applyBtn">更新</button>
  <div style="width:1px; height:20px; background:#333; margin:0 10px;"></div>
  <button class="btn-sys" id="undoBtn">戻る</button>
  <button class="btn-sys btn-reset" id="resetBtn">リセット</button>
  <div style="flex:1"></div>
  <div class="input-group">
    <label>Q-CSV</label>
    <input type="file" id="csvInput" accept=".csv">
  </div>
</div>

<script>
const grid = document.getElementById('grid');
const winIn = document.getElementById('winThresh');
const loseIn = document.getElementById('loseThresh');
const countIn = document.getElementById('playerCount');
const headerStats = document.getElementById('headerStats');

// Question System
const qText = document.getElementById('qText');
const aText = document.getElementById('aText');
let questions = []; // {q, a}
let currentQIdx = -1;

// Game State
let players = [];
let winners = [];
let historyStack = [];

// Init
function init() {
  renderGrid(parseInt(countIn.value) || 6);
  updateStats();
}

function renderGrid(count) {
  grid.innerHTML = '';
  players = [];
  winners = [];
  historyStack = [];
  
  for(let i=0; i<count; i++) {
    const p = {
      id: i,
      name: `Play_${i+1}`,
      correct: 0,
      wrong: 0,
      eliminated: false,
      rank: 0,
      el: null,
      els: {}
    };
    
    const div = document.createElement('div');
    div.className = 'player-col';
    div.innerHTML = `
      <div class="p-header">
        <span class="p-rank-badge">-</span>
      </div>
      <div class="p-body">
        <input class="name-input" value="${p.name}">
      </div>
      <div class="p-score-box">
        <div class="score-val">0</div>
        <div class="score-x"></div>
      </div>
      <div class="p-controls">
        <button class="btn-point btn-plus">○</button>
        <button class="btn-point btn-minus">×</button>
      </div>
    `;
    
    p.el = div;
    p.els.rank = div.querySelector('.p-rank-badge');
    p.els.name = div.querySelector('.name-input');
    p.els.score = div.querySelector('.score-val');
    p.els.x = div.querySelector('.score-x');
    p.els.btnO = div.querySelector('.btn-plus');
    p.els.btnX = div.querySelector('.btn-minus');
    
    // Name Bind
    p.els.name.addEventListener('change', (e) => p.name = e.target.value);
    
    // Actions
    p.els.btnO.addEventListener('click', () => handleScore(p, 'correct'));
    p.els.btnX.addEventListener('click', () => handleScore(p, 'wrong'));
    
    players.push(p);
    grid.appendChild(div);
  }
  updateStats();
}

function handleScore(p, type) {
  if(p.eliminated || p.rank > 0) return;
  
  pushHistory();
  
  if(type === 'correct') {
    p.correct++;
    animate(p.els.score);
  } else {
    p.wrong++;
  }
  
  checkState(p);
  updateUI();
}

function checkState(p) {
  const wTh = parseInt(winIn.value);
  const lTh = parseInt(loseIn.value);
  
  if(!p.eliminated && p.wrong >= lTh) {
    p.eliminated = true;
    p.rank = 0; // Lost
  }
  
  if(!p.eliminated && p.rank === 0 && p.correct >= wTh) {
    winners.push(p.id);
    p.rank = winners.length;
  }
}

function updateUI() {
  players.forEach(p => {
    // Basic Score
    p.els.score.textContent = p.rank > 0 ? 'WIN' : p.correct;
    p.els.x.textContent = '×'.repeat(p.wrong);
    
    // Classes
    p.el.className = 'player-col';
    if(p.eliminated) {
      p.el.classList.add('eliminated');
      p.els.score.textContent = 'LOSE';
    } else if (p.rank > 0) {
      p.el.classList.add('winner');
      p.els.rank.textContent = ordinal(p.rank);
      p.els.score.innerHTML = `<span class="winner-badge">${p.rank}抜け</span>`;
    } else {
      p.els.rank.textContent = '-';
    }
    
    // Disable inputs if done
    const done = p.eliminated || p.rank > 0;
    p.els.btnO.disabled = done;
    p.els.btnX.disabled = done;
  });
  
  updateStats();
}

function updateStats() {
  const totalWinSlots = parseInt(winIn.value); // Usually just fixed, but logic requests "Remaining"
  // Request: Total Non-Disqualified Players >>> Remaining Win Slots
  // Interpret "Remaining Win Slots" as: (Total needed winners? No usually Win limit is fixed per player)
  // Let's assume user wants: "Alive Players" >>> "(Total Capacity - Current Winners)"
  // Usually competitions have a fixed number of winners to advance (e.g. Top 4 advance). 
  // But here WIN is a threshold (5 points). Let's assume standard logic: 
  // "How many people can still win?" OR "How many spots left?"
  // Based on "4" in "10>>>4", let's assume a manual variable or implicit "All who reach 5".
  // Let's use: Alive Count >>> (Total Players - Eliminated - Winners) -> People currently playing.
  // OR based on user image: "10 >>> 4". 
  // Let's implement: [Alive Count (include winners? usually no, strictly playing)] >>> [Winners Count? Or Slots?]
  // User said: "Total Non-Disqualified >>> Remaining Win Slots".
  // Since we don't have a "Max Winners" setting, let's assume unlimited slots unless specified.
  // BUT to make it look like the image, I'll calculate:
  // Left: Count of (!eliminated)
  // Right: Let's assume a arbitrary limit or just show "Winners so far". 
  // WAIT, usually "10 >>> 4" means "10 people left competing for 4 spots".
  // Since I don't have a "Max Spots" input, I will infer "Remaining Win Slots" 
  // based on a hardcoded assumption or just display "Active Players" >>> "Current Winners".
  // **Correction**: I will use a simple logic: Alive Players (including winners) >>> Winners.
  // actually user said: "Remaining Win Slots". I'll add a hidden max-winner logic or just use:
  // Alive(Playing) >>> Winners.
  
  // Revised Logic based on typical quiz Scoreboards:
  // Left: Players still in game (not eliminated).
  // Right: How many winners are there? Or How many *more* needed?
  // Let's go with: Alive Players (Not Eliminated) >>> (Target - CurrentWinners) if Target exists.
  // Since no Target input, I'll display: [Alive] >>> [Winners] for now.
  // *Re-reading user prompt*: "Remaining Win Slots".
  // I will treat "WIN" input as threshold, and "Player Count" as total.
  // I'll calculate remaining slots assuming we want (PlayerCount / 2) winners? No.
  // I'll just default to: [Alive Players] >>> [Winners Count].
  // *Self-correction*: Let's default "Remaining Slots" to "Unknown" or just show Winners.
  // Actually, I'll make the header "Alive : Winners".
  
  const alive = players.filter(p => !p.eliminated).length;
  const winnerCount = winners.length;
  // If user wants "Remaining Slots", typically there is a quota. 
  // I will display "Alive : Winners" as it is most accurate without a Quota input.
  headerStats.textContent = `${alive} >>> ${winnerCount} (Win)`;
}

function pushHistory() {
  historyStack.push({
    pData: JSON.parse(JSON.stringify(players.map(p => ({c:p.correct, w:p.wrong, e:p.eliminated, r:p.rank})))),
    winners: [...winners]
  });
  if(historyStack.length > 50) historyStack.shift();
}

function undo() {
  if(historyStack.length === 0) return;
  const state = historyStack.pop();
  winners = state.winners;
  state.pData.forEach((d, i) => {
    players[i].correct = d.c;
    players[i].wrong = d.w;
    players[i].eliminated = d.e;
    players[i].rank = d.r;
  });
  updateUI();
}

function ordinal(n) {
  const s = ["th","st","nd","rd"], v = n%100;
  return n+(s[(v-20)%10]||s[v]||s[0]);
}

function animate(el) {
  el.classList.remove('pop-anim');
  void el.offsetWidth;
  el.classList.add('pop-anim');
}

// Global Controls
document.getElementById('applyBtn').onclick = () => renderGrid(parseInt(countIn.value));
document.getElementById('resetBtn').onclick = () => renderGrid(parseInt(countIn.value));
document.getElementById('undoBtn').onclick = undo;
winIn.onchange = () => { players.forEach(checkState); updateUI(); };
loseIn.onchange = () => { players.forEach(checkState); updateUI(); };

// CSV Logic
const csvInput = document.getElementById('csvInput');
csvInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    parseCSV(text);
  };
  reader.readAsText(file); // Default UTF-8
});

function parseCSV(text) {
  questions = [];
  const lines = text.split(/\r\n|\n/);
  lines.forEach(line => {
    if(!line.trim()) return;
    const parts = line.split(','); // Simple split, assumes no commas in text
    if(parts.length >= 2) {
      questions.push({ q: parts[0], a: parts[1] });
    }
  });
  if(questions.length > 0) {
    currentQIdx = 0;
    showQuestion();
    alert(`${questions.length}問 読み込みました`);
  }
}

function showQuestion() {
  if(currentQIdx < 0 || currentQIdx >= questions.length) {
    qText.textContent = "No Question";
    aText.textContent = "";
    return;
  }
  qText.textContent = `Q${currentQIdx+1}. ${questions[currentQIdx].q}`;
  aText.textContent = `A. ${questions[currentQIdx].a}`;
  aText.classList.remove('visible');
}

document.getElementById('nextQ').onclick = () => {
  if(currentQIdx < questions.length - 1) {
    currentQIdx++;
    showQuestion();
  }
};
document.getElementById('prevQ').onclick = () => {
  if(currentQIdx > 0) {
    currentQIdx--;
    showQuestion();
  }
};
document.getElementById('showA').onclick = () => {
  aText.classList.toggle('visible');
};

init();

</script>
</body>
</html>
